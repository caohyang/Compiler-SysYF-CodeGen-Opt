## 编译原理PW7实验报告

##### 小组成员、分工与贡献度：

PB19000046  曹奕阳（必做Part1--公共子表达式删除；贡献度25%）

PB19000254  薛东昀（必做Part2--活跃变量分析；贡献度25%）

PB19000372  孙杰（必做Part3--支配树算法，选做1--常量传播、死代码删除；贡献度50%）

### 必做 Part1：公共子表达式删除

#### B1-1 设计思路

* 计算可用表达式。这里采用课件上的分析方法，在本实验中按如下方式实现：

（1）**定义**`bb_gen[B]`：块B产生的可用表达式集合， `bb_kill[B]`：块B注销的可用表达式集合，`bb_in[B]`：块B入口的可用表达式集合，`bb_out[B]`：块B出口的可用表达式集合。

（2）利用**数据流等式**进行迭代计算，对基本块B计算`bb_in[B]`和`bb_out[B]`。若`bb_out[B]`集合大小不变则结束迭代，得到最终结果。$$bb\_out[B]=bb\_gen[B]\bigcup (bb\_in[B]-bb\_kill[B])$$ $$bb\_in[B]=\bigcap_{P是B的前驱}bb\_out[P]$$ $$bb\_in[ENTRY]=\emptyset $$

* 公共子表达式的删除。对SSA形式的中间代码，将每条指令看作一个表达式，在基本块B中删去`bb_in[B]`中出现的表达式（指令）。实现过程中通过替代关系表`replace_map`递归寻找公共表达式最早出现的位置，并用该位置的信息替代之后出现的相同表达式。

一些思考：将完整的指令作为表达式，很难起到应有的优化效果。一种思路是将指令中等号右边的部分提取出来作为可用表达式，用等号左边的部分来注销表达式。但在现有的接口下，这种思路的具体实现并不容易，因为涉及到指令的部分修改和提取、注销表达式的字符串匹配等因素。

#### B1-2

> 若要将call指令、load指令列入公共子表达式删除的考虑范围，除了你实现的公共子表达式删除算法，还需要考虑哪些其他因素？

call指令实现函数跳转，需要通过访问链考虑表达式的作用域。load指令是否能删除，需要考虑指令加载地址存储的内容是否发生了变化，如变量重新赋值、空间释放等情况则不可删除。

### 必做 Part2：活跃变量分析

#### B2-1

use和def的求解较为简单。

1. 由于以基于SSA形式的CFG进行分析，所以所有分析的指令都是SSA的。因此，对于def，我们只要把所有的非空指令存储即可。见ActiveVar::get_def()
2. 而对于use，由于指令是SSA的，因此不可能出现i=i+1的情况，所以只需要把每条指令的所有operand加入use并且剔除def中的内容即可。见ActiveVar::get_use()

活跃变量分析的主要难点在于phi的引入。为此，我们需要修改迭代公式。
$$
IN = use\bigcup phi \bigcup(OUT-def)\\
OUT = \bigcup_{suc}(IN[suc]-phi^*[suc])
$$
其中$phi^*$表示suc的phi指令中不从该节点分支进入suc且在其他地方不需要的变量集合。

这部分最主要的工作就在于$phi^*$的计算：

1. 找到所有suc中phi命令里面不从当前节点分支继承的变量，记录为集合$phi_0$

2. 顺着这些变量的使用链(Value::get_use_list)找到所有的使用该变量的在suc中(Instruction::get_parent())指令

3. 如果该指令不是phi指令，则必然从当前节点继承，否则根据phi指令的分支判断变量是否从当前节点继承

4. 最终把所有从当前节点继承的从$phi_0$删除得到$phi^*$

### 必做 Part3：支配树算法

#### B3-1 Proof

因为 **x** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **x** ，即所有 **s->b** 的路径可以表示为 **s->x->b** 。又因为存在 **y->b** ，所以 **y** 一定处于 **s->x** 或者 **x->b** 中任意一个。

1. **y** 处于 **s->x** 中：

   又因为 **y** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **y** 。因为要到达 **b** 需先到达 **x** ，所以等价于从 **s** 到 **x** 的路径 **s->x** 必定经过 **y** ，即 **y** 支配 **x** 

2. **y** 处于 **x->b** 中：

   又因为 **y** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **y** 。因为要到达 **b** 需先到达 **x** ，所以等价于从 **x** 到 **b** 的路径 **x->b** 必定经过 **y** ，即 **x** 支配 **y** 

#### B3-2 

是必须的，原因如下：

**后序遍历的逆序** 是一种先计算祖先结点后计算叶子结点的顺序。

正如在文中提到的，计算支配关系的一个天然顺序是从祖先结点到叶子结点。因为计算出祖先结点的 **Dom(father)** 后可以用此结果来计算叶子结点 **Dom(son)** 。若先计算 **Dom(son)** 后计算 **Dom(father)** ，则会大大降低收敛速度。

#### B3-3

是必须的，理由同B3-2。

#### B3-4

下半部分的 `intersect` 的作用是迭代 **idom** 最终找到该节点的支配点。

小于号不能改为大于号，原因如下：

因为结点标号是后序遍历，所以想要找到 **dom** 需要想上寻找，也就是对 **finger** 较小的那一个赋值为 **doms[finger]** ，从而可以向上找到 **dom**.

#### B3-5

时间上收敛更快，占用空间更小。

#### B3-6

由`BasicBlock.cpp`中的定义可知，一个基本块的终结指令即为最后一条指令，通过调用`get_terminator`函数，得到该指令的类型为跳转指令、返回指令或其他）。对每个`BasicBlock`，判断其终结指令的类型，若为返回指令，则该基本块为`EXIT`节点。不能以流图中的最后一个基本块为`EXIT`节点，因为流图中基本块的顺序为深度优先遍历基本块的顺序，有可能在遍历过程中先访问`EXIT`节点，再回退访问其他节点，故应根据终结指令的类型加以判断。

### 选做1：进阶优化（常量传播、死代码删除）

