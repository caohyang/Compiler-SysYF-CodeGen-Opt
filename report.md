## 编译原理PW7实验报告

##### 小组成员、分工与贡献度：

PB19000046  曹奕阳（必做Part1；贡献度25%）

PB19000254  薛东昀（必做Part2；贡献度25%）

PB19000372  孙杰（必做Part3，选做1的两项任务；贡献度50%）

### 必做 Part1：公共子表达式删除

#### B1-1



#### B1-2



### 必做 Part2：活跃变量分析

#### B2-1

use和def的求解较为简单。

1. 由于以基于SSA形式的CFG进行分析，所以所有分析的指令都是SSA的。因此，对于def，我们只要把所有的非空指令存储即可。见ActiveVar::get_def()
2. 而对于use，由于指令是SSA的，因此不可能出现i=i+1的情况，所以只需要把每条指令的所有operand加入use并且剔除def中的内容即可。见ActiveVar::get_use()

活跃变量分析的主要难点在于phi的引入。为此，我们需要修改迭代公式。
$$
IN = use\bigcup phi \bigcup(OUT-def)\\
OUT = \bigcup_{suc}(IN[suc]-phi^*[suc])
$$
其中$phi^*$表示suc的phi指令中不从该节点分支进入suc且在其他地方不需要的变量集合。

这部分最主要的工作就在于$phi^*$的计算：

1. 找到所有suc中phi命令里面不从当前节点分支继承的变量，记录为集合$phi_0$

2. 顺着这些变量的使用链(Value::get_use_list)找到所有的使用该变量的在suc中(Instruction::get_parent())指令

3. 如果该指令不是phi指令，则必然从当前节点继承，否则根据phi指令的分支判断变量是否从当前节点继承

4. 最终把所有从当前节点继承的从$phi_0$删除得到$phi^*$

### 必做 Part3：支配树算法

#### B3-1 Proof

因为 **x** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **x** ，即所有 **s->b** 的路径可以表示为 **s->x->b** 。又因为存在 **y->b** ，所以 **y** 一定处于 **s->x** 或者 **x->b** 中任意一个。

1. **y** 处于 **s->x** 中：

   又因为 **y** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **y** 。因为要到达 **b** 需先到达 **x** ，所以等价于从 **s** 到 **x** 的路径 **s->x** 必定经过 **y** ，即 **y** 支配 **x** 

2. **y** 处于 **x->b** 中：

   又因为 **y** 支配 **b** ，所以从 **s** 到 **b** 的路径 **s->b** 必定经过 **y** 。因为要到达 **b** 需先到达 **x** ，所以等价于从 **x** 到 **b** 的路径 **x->b** 必定经过 **y** ，即 **x** 支配 **y** 

#### B3-2 

是必须的，原因如下：

**后序遍历的逆序** 是一种先计算祖先结点后计算叶子结点的顺序。

正如在文中提到的，计算支配关系的一个天然顺序是从祖先结点到叶子结点。因为计算出祖先结点的 **Dom(father)** 后可以用此结果来计算叶子结点 **Dom(son)** 。若先计算 **Dom(son)** 后计算 **Dom(father)** ，则会大大降低收敛速度。

#### B3-3

是必须的，理由同B3-2。

#### B3-4

下半部分的 `interation` 的作用是迭代 **idom** 最终到找该节点的支配点。

小于号不能改为大于号，原因如下：

因为结点标号是后序遍历，所以想要找到 **dom** 需要想上寻找，也就是对 **finger** 较小的那一个赋值为 **doms[finger]** ，从而可以向上找到 **dom**

#### B3-5

时间上收敛更快，占用空间更小

### 选做1：进阶优化（常量传播、死代码删除）

